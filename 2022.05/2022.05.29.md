
## 题目地址(688. 骑士在棋盘上的概率)

https://leetcode.cn/problems/knight-probability-in-chessboard/

## 题目描述

```
在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 k 步或离开了棋盘。

返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。

 

示例 1：

输入: n = 3, k = 2, row = 0, column = 0
输出: 0.0625
解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。


示例 2：

输入: n = 1, k = 0, row = 0, column = 0
输出: 1.00000


 

提示:

1 <= n <= 25
0 <= k <= 100
0 <= row, column <= n
```

## 前置知识

- 动态规划

## 公司

- 暂无

## 思路
用P(A_i)表示第i步 马留在棋盘上的概率 那么经过k次移动  
马仍留在棋盘上的概率为P(A_1)*P(A_2)...*P(A_k)  
采用动态规划+滑动数据  
使用n*n*2表示第i轮，马移动情况以及第i+1轮移动情况  
从第一轮开始，（1<=i<=k），使用i&1表示轮次，i&1==1表示奇数轮；i&1==0表示偶数轮。
## 关键点

-  滑动数组

## 代码

- 语言支持：Python3

Python3 Code:

```python

DIRS = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        """
        计算马留在棋盘上的概率 
        """
        dp = [[[1] * 2 for _ in range(n)] for _ in range(n)]
        for i in range(1, k + 1):
            for r in range(n):
                for c in range(n):
                    # i为奇数时 i&1==1; i为偶数时，i&1==0
                    dp[r][c][i&1] = 0
                    for dir in DIRS:
                        if 0 <= (nr := r + dir[0]) < n and 0 <= (nc := c + dir[1]) < n:
                            dp[r][c][i&1] += dp[nr][nc][(i-1)&1] / 8
        return dp[row][column][k&1]
```


**复杂度分析**

令 n 为数组长度，k为走的步数。

- 时间复杂度：$O(k*n^2)$
- 空间复杂度：$O(n^2)$
